<%
func capitalizedName(for variable: Variable) -> String {
    return "\(String(variable.name.first!).capitalized)\(String(variable.name.dropFirst()))"
}
func customDecodingMethod(for variable: Variable, of type: Type) -> SourceryMethod? {
    return type.staticMethods.first { $0.selectorName == "decode\(capitalizedName(for: variable))(from:)" }
}
func defaultDecodingValue(for variable: Variable, of type: Type) -> Variable? {
    return type.staticVariables.first { $0.name == "default\(capitalizedName(for: variable))" }
}
func decodingContainerMethod(for type: Type) -> SourceryMethod? {
    return type.staticMethods.first { $0.selectorName == "decodingContainer(_:)" }
}
func customEncodingMethod(for variable: Variable, of type: Type) -> SourceryMethod? {
    return type.instanceMethods.first { $0.selectorName == "encode\(capitalizedName(for: variable))(to:)" }
}
func encodeAdditionalVariablesMethod(for type: Type) -> SourceryMethod? {
    return type.instanceMethods.first { $0.selectorName == "encodeAdditionalValues(to:)" }
}
func encodingContainerMethod(for type: Type) -> SourceryMethod? {
    return type.instanceMethods.first { $0.selectorName == "encodingContainer(_:)" }
}
func needsDecodableImplementation(for type: Type) -> Bool {
    let implementsProtocol = type.implements["AutoDecodable"] != nil
    let hasCustomMethods = type.storedVariables.contains(where: { customDecodingMethod(for: $0, of: type) != nil })
    let hasDefaultValues = type.storedVariables.contains(where: { defaultDecodingValue(for: $0, of: type) != nil })
    let hasContainerMethod = decodingContainerMethod(for: type) != nil
    return implementsProtocol && (hasCustomMethods || hasDefaultValues || hasContainerMethod)
}
func needsEncodableImplementation(for type: Type) -> Bool {
    let implementsProtocol = type.implements["AutoEncodable"] != nil
    let hasCustomMethods = type.variables.contains(where: { customEncodingMethod(for: $0, of: type) != nil })
    let hasAdditionalMethod = encodeAdditionalVariablesMethod(for: type) != nil
    let hasContainerMethod = decodingContainerMethod(for: type) != nil
    return implementsProtocol && (hasCustomMethods || hasAdditionalMethod || hasContainerMethod)
}
-%>
<%_ for type in types.structs { -%>
    <%_ guard type.implements["AutoDecodable"] != nil || type.implements["AutoEncodable"] != nil else { continue } -%>
    <%_ if let codingKeysType = type.containedType["CodingKeys"] as? Enum { -%>
        <%_ let definedKeys = Set(codingKeysType.cases.map({ $0.name })) -%>
        <%_ let allStoredVariablesKeys = type.storedVariables.map({ $0.name }) -%>
        <%_ let allComputedVariablesKeys = type.computedVariables.filter({ customEncodingMethod(for: $0, of: type) != nil }).map({ $0.name }) -%>

        <%_ if (allStoredVariablesKeys.count + allComputedVariablesKeys.count) > definedKeys.count { -%>
// sourcery:inline:auto:<%= codingKeysType.name %>.AutoCodable
        <%_ for key in allStoredVariablesKeys where !definedKeys.contains(key) { -%>
        case <%= key %>
        <%_ } -%>
        <%_ for key in allComputedVariablesKeys where !definedKeys.contains(key) { -%>
        case <%= key %>
        <%_ } -%>
// sourcery:end

<%      } -%>
<%_ } -%>

    <%_ let typeNeedsDecodableImplementation = needsDecodableImplementation(for: type) -%>
    <%_ let typeNeedsEncodableImplementation = needsEncodableImplementation(for: type) -%>
    <%_ guard typeNeedsDecodableImplementation || typeNeedsEncodableImplementation else { continue } -%>
extension <%= type.name %> {
    <%_ if type.containedType["CodingKeys"] as? Enum == nil { -%>

    enum CodingKeys: String, CodingKey {
        <%_ for variable in type.storedVariables { -%>
        case <%= variable.name %>
        <%_ } -%>
        <%_ for variable in type.computedVariables { -%>
        <%_ guard customEncodingMethod(for: variable, of: type) != nil else { continue }-%>
        case <%= variable.name %>
        <%_ } -%>
    }

    <%_ } else { -%>

    <%_ } -%>
    <%_ if typeNeedsDecodableImplementation { -%>
    <%= type.accessLevel %> init(from decoder: Decoder) throws {
        <%_ if let containerMethod = decodingContainerMethod(for: type) { -%>
        let container = <% if containerMethod.throws { %>try <% } %><%= type.name %>.decodingContainer(decoder)
        <%_ } else { -%>
        let container = try decoder.container(keyedBy: CodingKeys.self)
        <%_ } -%>

        <%_ for variable in type.storedVariables { -%>
        <%_ let defaultValue = defaultDecodingValue(for: variable, of: type) -%>
        <%_ let customMethod = customDecodingMethod(for: variable, of: type) -%>
        <%_ let shouldWrapTry = defaultValue != nil && (customMethod?.throws == true || customMethod == nil) -%>
        <%_ let tryOpen = shouldWrapTry ? "(try?" : "try" -%>
        <%_ let tryClose = shouldWrapTry ? ")" : "" -%>
        <%_ if let customMethod = customMethod { -%>
        <%= variable.name %> = <% if customMethod.throws { %><%= tryOpen %> <% } %><%= type.name %>.<%= customMethod.callName %>(from: <% if customMethod.parameters.first?.name == "decoder" { %>decoder<% } else { %>container<% } %>)<% -%>
        <%_ } else { -%>
        <%= variable.name %> = <%= tryOpen %> container.decode<% if variable.isOptional { %>IfPresent<% } %>(<%= variable.unwrappedTypeName %>.self, forKey: .<%= variable.name %>)<% -%>
        <%_ } -%>
        <%_ %><%= tryClose -%>
        <%_ if let defaultValue = defaultValue { %> ?? <%= type.name %>.<%= defaultValue.name %>
        <%_ } else { %>
        <%_ } -%>
        <%_ } -%>
    }

    <%_ } -%>
    <%_ if typeNeedsEncodableImplementation { -%>
    <%= type.accessLevel %> func encode(to encoder: Encoder) throws {
        <%_ if let containerMethod = encodingContainerMethod(for: type) { -%>
        var container = encodingContainer(encoder)
        <%_ } else { -%>
        var container = encoder.container(keyedBy: CodingKeys.self)
        <%_ } -%>

        <%_ for variable in type.variables { -%>
        <%_ let customMethod = customEncodingMethod(for: variable, of: type) -%>
        <%_ if let customMethod = customMethod { -%>
        <% if customMethod.throws { %>try <% } %><%= customMethod.callName %>(to: <% if customMethod.parameters.first?.name == "encoder" { %>encoder<% } else { %>&container<% } %>)
        <%_ } else if !variable.isComputed && !variable.isStatic { -%>
        try container.encode<% if variable.isOptional { %>IfPresent<% } %>(<%= variable.name %>, forKey: .<%= variable.name %>)
        <%_ } -%>
        <%_ } -%>
        <%_ if let encodeAdditional = encodeAdditionalVariablesMethod(for: type) { -%>
        <% if encodeAdditional.throws { %>try <% } %><%= encodeAdditional.callName %>(to: <% if encodeAdditional.parameters.first?.name == "encoder" { %>encoder<% } else { %>&container<% } %>)
        <%_ } -%>
    }

    <%_ } -%>
}
<% } -%>
